%\VignetteIndexEntry{An introduction to QuasR}
%\VignetteDepends{}
%\VignetteKeywords{XXXKexword}
%\VignettePackage{QuasR}

\documentclass[10pt]{article}

\usepackage{times}
%\usepackage{inconsolata}
%\usepackage[scaled=0.85]{beramono}
\usepackage{hyperref} % remove to suppress links
%\usepackage[super]{natbib}
%\usepackage[numbers]{natbib}


% the following three are needed to include function documentations (importing of Rd causes pdflatex to fail???)
%\usepackage[times,hyper]{Rd}
%\usepackage[latin1]{inputenc}
%\usepackage{makeidx}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}

\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}
\newcommand{\QuasR}{\Rpackage{QuasR}}
\newcommand{\qProject}{\Robject{qProject}}
\newcommand{\bam}{\texttt{BAM}}
\newcommand{\fasta}{\texttt{FASTA}}
\newcommand{\fastq}{\texttt{FASTQ}}


\title{An Introduction to \QuasR{}}
\author{Anita Lerch, Michael Stadler}
\date{Modified: 8 January, 2012. Compiled: \today}

\begin{document}
%\bibliographystyle{plain}
\bibliographystyle{unsrt}
%\bibliographystyle{plainnat}


\maketitle

<<options,echo=FALSE>>=
options(width=60)
library(BSgenome)
library(QuasR)
@

\tableofcontents

\newpage


\section{Introduction}

The \QuasR{} package (short for \underline{Qu}antify and \underline{a}nnotate \underline{s}hort reads in \underline{R}) integrates the functionality of several \R{} packages (such as \Rpackage{IRanges} and \Rpackage{Rsamtools}) and external software (e.g. \software{bowtie}, through the \Rpackage{Rbowtie} package). The package aims to cover the whole analysis workflow of typical ultra-high throughput sequencing experiments, starting from the raw sequence reads, over pre-processing and alignment, up to quantification. A single \R{} script can contain all steps of a complete analysis, making it simple to document, reproduce or share the workflow containing all relevant details.

The current \QuasR{} release supports the analysis of single read ChIP-seq experiments (chromatin immuno-precipitation combined with sequencing). Support for paired-end sequencing experiments, and for RNA-seq (expression profiling) and Bis-seq (DNA methylation profiling) experiments will be added in successive future releases.

\section{Preliminaries}

%\subsection{Citing \QuasR{}}
%\cite{QuasR}
%TODO

\subsection{Installation}
\QuasR{} is a package for the \R{} computing environment and it is assumed that you have already installed \R{}. See the \R{} project at \url{http://www.r-project.org}. To install the latest version of \QuasR{}, you will need to be using the latest version of \R{}. \QuasR{} is part of the Bioconductor project at \url{http://www.bioconductor.org}. To get \QuasR{} together with its dependencies you can use
<<install, eval=FALSE>>=
source("http://www.bioconductor.org/biocLite.R")
biocLite("QuasR")
@

Bioconductor works on a 6-monthly official release cycle, lagging each major \R{} release by a short time. As with other Bioconductor packages, there are always two versions of \QuasR{}. Most users will use the current official release version, which will be installed by \Rcode{biocLite} if you are using the current version of \R{}. There is also a developmental version of \QuasR{} that includes new features due for the next official release. The developmental version will be installed if you are using the developmental version of \R{}. The official release version always has an even second number (for example 0.2.1), whereas the developmental version has an odd second number (for example 0.3.6).

\subsection{How to get help}
Most questions about \QuasR{} will hopefully be answered by the documentation or references. If you've run into a question which isn't addressed by the documentation, or you've found a conflict between the documentation and software itself, then there is an active support community which can offer help.
The authors of the package always appreciate receiving reports of bugs in the package functions or in the documentation. The same goes for well-considered suggestions for improvements.
Any other questions or problems concerning \QuasR{} should be sent to the Bioconductor mailing list \url{bioconductor@stat.math.ethz.ch}. To subscribe to the mailing list, see \url{https://stat.ethz.ch/mailman/listinfo/bioconductor}. Please send requests for general assistance and advice to the mailing list rather than to the individual authors. Users posting to the mailing list for the first time should read the helpful posting guide at \url{http://www.bioconductor.org/doc/postingGuide.html}. Note that each function in \QuasR{} has it's own online help page, as described in the section \ref{sec:Rintro}. Mailing list etiquette requires that you read the relevant help page carefully before posting a problem to the list.


\newpage
\section{Quick Start}
\subsection{A brief introduction to \R{}}
\label{sec:Rintro}
Much in this vignette and in particular this section is based on the excellent user guide of the \Rpackage{limma} package, which we would like to hereby acknowledge.

\R{} is a program for statistical computing. It is a command-driven language meaning that you have to type commands into it rather than pointing and clicking using a mouse. In this guide it will be assumed that you have successfully downloaded and installed \R{} from \url{http://www.r-project.org}. A good way to get started is to type
<<help1, eval=FALSE>>=
help.start()
@ 
at the \R{} prompt or, if you're using \R{} for Windows, to follow the drop-down menu items \textit{Help} $\succ$ \textit{Html help}. Following the links \textit{Packages} $\succ$ \Rpackage{QuasR} from the html help page will lead you to the contents page of help topics for functions in \QuasR{}.
Before you can use any \QuasR{} commands you have to load the package by typing
<<loadQuasRLibrary, eval=FALSE>>=
library(QuasR)
@ 
at the \R{} prompt. You can get help on any function in any loaded package by typing \Rcode{?} and the function name at the \R{} prompt, for example
<<help2, eval=FALSE>>=
?preprocessReads
@ 
or equivalently
<<help3, eval=FALSE>>=
help("preprocessReads")
@ 
for detailed help on the \Rfunction{preprocessReads} function. The individual function help pages are especially important for listing all the arguments which a function will accept and what values the arguments can take.

A key to understanding \R{} is to appreciate that anything that you create in \R{} is an \textit{object}. Objects might include data sets, variables, functions, anything at all. For example
<<assign, eval=FALSE>>=
x <- 2
@ 
will create a variable \Rcode{x} and will assign it the value 2. At any stage of your \R{} session you can type
<<objects, eval=FALSE>>=
objects()
@ 
to get a list of all the objects you have created. You can see the contents of any object by typing the name of the object at the prompt, for example either of the following commands will print out the contents of \Rcode{x}:
<<printObject, eval=FALSE>>=
show(x)
x
@ 
We hope that you can use \QuasR{} without having to spend a lot of time learning about the \R{} language itself but a little knowledge in this direction will be very helpful, especially when you want to do something not explicitly provided for in \QuasR{} or in the other Bioconductor packages. For more details about the \R{} language see \textit{An Introduction to R} which is available from the online help. For more background on using \R{} for statistical analysis see \cite{Dalgaard}.


\subsection{Sample \QuasR{} session}
This is a quick overview of what an analysis might look like for the users who prefer to jump right into an analysis. The example assumes an that the sequence files to be analyzed are listed in the \Rcode{samples.txt} file (see section \ref{sec:SampleFile} on page \pageref{sec:SampleFile} for details). The sequence reads will be aligned using \software{bowtie} \cite{bowtie} (from the \Rpackage{Rbowtie} package \cite{Rbowtie}) to the mouse genome (contained in the \Rpackage{BSgenome.Mmusculus.UCSC.mm9} package). A quality control report will be saved to the \Rcode{qc\_report.pdf} file and read alignments will be quantified in promoter regions, whose genomic coordinates are contained in the \Rcode{GRanges}-object with the name \Rcode{promoters}.

<<SampleSession1, eval=FALSE>>=
project <- qProject(sampleFile="samples.txt",
                    genome="BSgenome.Mmusculus.UCSC.mm9",
                    aligner="Rbowtie")
qAlign(project)
qQCReport(project, "qc_report.pdf")
promoterCounts <- qCount(project, query=promoters)
@

The \Robject{project} object keeps track of all the metadata (where sequence and alignment files are, what aligner and genome was used, and information on qualities of sequences and alignments). It may be convenient to save this metadata for later use by
<<SampleSession2, eval=FALSE>>=
projectFilename <- qSaveProject(project)
project <- qReadProject(projectFilename)
@

%\subsection{Data objects}
%TODO


\newpage
\section{\QuasR{} Overview}
The following scheme shows the major components of \QuasR{} and their relationships:
\begin{figure}[!h]
\begin{center}
\includegraphics{QuasR-scheme.png}
\caption{QuasR package overview}
\label{fig:QuasR-scheme}
\end{center}
\end{figure}

\QuasR{} works with data (sequence files, alignment files, genome sequence and index, etc.) that are stored as files on your hard disk (the gray box on the left of Figure \ref{fig:QuasR-scheme}). There is no need to setup and maintain a database management system, and neither to copy the files into a specific place or directory.

In order to keep track of directory paths, as well as the current state of the analysis, \QuasR{} makes use of a \qProject{} object. A typical analysis therefore starts with the creation of a \qProject{} object, which at the minimum requires two inputs: the name of a samples text file (see section \ref{sec:SampleFile} for details), and the reference genome for the alignments (see section \ref{sec:refGenome} for details).

During the analysis, the \qProject{} object is the main argument passed to each function; it contains all necessary information on the current project and eliminates the need to repeatedly enter the same information (such as the reference genome). All functions that work on \qProject{} objects can be recognized by their names starting with the letter \textit{q}. These \textit{q-functions} will also update the \qProject{} object with additional information, for example \Rfunction{qAlign} will store the path and file names of the generated alignments, and \Rfunction{qQCReport} will store the collected quality information. The q-functions can update the original \qProject{} object passed to them. It is therefore not necessary to assign return values from q-functions in order to keep their results.

The \Rfunction{qSaveProject} and \Rfunction{qReadProject} can be used to save a \qProject{} object to a file and open it again.

Finally, the main workhorse of \QuasR{} is the \Rfunction{qCount} function: It counts the alignments in regions of interest (e.g. promoters, genes, exons, etc.) and produces a count table (regions in rows, samples in columns) for further analysis, e.g. using packages \Rpackage{edgeR} \cite{edgeR} or \Rpackage{DESeq} \cite{DESeq}.

\vskip 4em

In summary, a typical \QuasR{} analysis consists of the following steps (some of them being optional):
\begin{quote}
\begin{itemize}
\item \Rfunction{preprocessReads} (optional): Remove adaptors from start or end of reads, filter out reads of low quality, short lenght or low complexity.
\item Prepare \textit{samples} file: List sequence files or alignments, provide sample names.
\item Prepare \textit{auxiliary} file (optional): List additional reference sequences for alignment of reads not matching the reference genome.
\item \Rfunction{qProject}: Create project object and specify project parameters (reference genome, aligner, etc.)
\item \Rfunction{qAlign}: Create alignments if not already existing. If necessary, create aligner index for reference genome and auxiliary references.
\item \Rfunction{qQCReport} (optional): Create quality control report with plots on sequence qualities and alignment statistics.
\item \Rfunction{qExportWig} (optional): Export genomic alignments as wiggle tracks for genome browser visualization.
\item \Rfunction{qSaveProject} (optional): Store the \qProject{} object for later reuse.
\item \Rfunction{qCount}: Quantify alignments in regions of interest.
\end{itemize}
\end{quote}



\newpage
\section{Example tasks}
\subsection{Create a sample file}
\label{sec:SampleFile}
The sample file is a tab-delimited text file with two columns or three columns. The first row contains the column names: For a single read experiment, these are 'SampleName' and 'FileName'; for a paired-end experiment, these are 'SampleName', 'FileName1' and 'FileName2'. These mandatory columns can appear in any order in the samples file, and additional columns may be contained in it. However, if the first row does not contain the corretly spelled names of the mandatory columns, \QuasR{} will not accept the samples file.

Here are examples of such sample files for a single read experiment:
\begin{center}
\ttfamily
\begin{tabular}{|ll|}
\hline
SampleName & FileName                \\
Sample1    & sr\_phiX174\_1\_1.fastq \\
Sample2    & sr\_phiX174\_2\_1.fastq \\
Sample2    & sr\_phiX174\_2\_2.fastq \\
\hline
\end{tabular}
\end{center}
\vskip 1em

and for a paired-end experiment:
\begin{center}
\ttfamily
\begin{tabular}{|lll|}
\hline
SampleName & FileName1               & FileName2               \\
Sample1    & sr\_phiX174\_1\_1.fastq & sr\_phiX174\_1\_2.fastq \\
Sample2    & sr\_phiX174\_2\_1.fastq & sr\_phiX174\_2\_2.fastq \\
\hline
\end{tabular}
\end{center}
\vskip 1em

These example files are also contained in the \QuasR{} package and may be used as templates. The path of the files can be determined using:
<<sampleFile, eval=FALSE>>=
sampleFile1 <- system.file(package="QuasR", "extdata",
                           "samples_phiX_single.txt")
sampleFile2 <- system.file(package="QuasR", "extdata",
                           "samples_phiX_paired.txt")
@

The \textit{SampleName} column contains sample names for each sequence file. The same name can be used on several lines to indicate multiple sequence files that belong to the same sample.

The \textit{FileName*} columns contain paths and names to files containing the sequence data. This allows combining files from different directories in a single analysis. By default, \QuasR{} will store the alignments in the same directory as the corresponding sequence file, and already existing alignment files with identical parameters will not be re-created, so that it is easy to reuse the same sequence files in multiple projects without unnecessarily copying sequence files or recreating alignments.

Three types of files can be listed in the \textit{FileName*} column:
\begin{itemize}
\item \textbf{\fasta{}} files have names that end with '.fa', '.fna' or '.fasta'. They contain only sequences (and no base qualities) and will thus be aligned on the basis of mismatches (the best alignment is the one with fewest mismatches).
\item \textbf{\fastq{}} files have names that end with '.fq' or '.fastq'. They contain sequences and corresponding base qualities and will be aligned using these qualities if supported by the selected aligner.
\item \textbf{\bam{}} files have names that end with '.bam'. They can be used if the sequence reads have already been aligned outside of \QuasR{}, and \QuasR{} will only be used for downstream analysis based on the alignments contained in the \bam{} files. This makes it possible to use alignment tools or parameters that are not already available within \QuasR{}, but making use of this option comes with a risk and should only be used by experienced users. For example, it cannot be guaranteed any more that certain assumptions made by \QuasR{} are fulfilled by the external aligner. In addition, some meta data, such as statistics on the alignments, which \QuasR{} store in the header of \bam{} files, will be missing from such external \bam{} files and the corresponding information may take a long time to regenerated, or may not be available at all.
\end{itemize}

\subsubsection*{Important remark on single- versus paired-end read experiments}
The sample file implicitely defines the type of samples contained in the project: \textit{single read} or \textit{paired-end read}. This type will have a profound impact on the downstream analysis. For example, it controls whether alignments will be performed in single or paired-end mode and whether the quantification will be based on single reads or read pairs. All samples within a project have the same type; it is not possible to mix both single and paired-end read samples in the same project and analyze each one respectively. It is however possible to include data from paired-end read experiments in a single read project, in which case they will be analyzed as single reads.


\subsection{Create an auxiliary file (optional)}
\label{sec:AuxFile}
By default \QuasR{} aligns reads to the reference genome only. However, it may be interesting to align non-matching reads to further references, for example to identify contamination from vectors or a different species, or in order to quantify spike-in material not contained in the reference genome. In \QuasR{}, such supplementary reference files are called \textit{auxiliary} references and can be specified when creating the \qProject{} object using the \Rfunarg{auxiliaryFile} argument (see section \ref{sec:qProject} on page \pageref{sec:qProject} for details). The format of the auxiliary file is similar to the one of the sample file described in section \ref{sec:SampleFile}: It contains two columns, with column names 'AuxName' and 'FileName' in the first row. Additional rows contain names and files of one or several auxiliary references in \fasta{} format.

An example auxiliary file looks like this:
\begin{center}
\ttfamily
\begin{tabular}{|ll|}
\hline
AuxName & FileName                       \\
lambda & phage\_genomes/NC\_001416.fna \\
\hline
\end{tabular}
\end{center}
\vskip 1em

and is available from your \QuasR{} installation at
<<auxiliaryFile, eval=TRUE>>=
auxFile <- system.file(package="QuasR", "extdata", "auxiliaries.txt")
@

\subsection{Select the reference genome}
\label{sec:refGenome}
Sequence reads will be primarily aligned against the reference genome. If necessary, \QuasR{} will create an index for the genome and store it for later reuse. The reference genome can be provided in three different formats:
\begin{itemize}
\item{\textbf a string}, referring to the name of a \Rpackage{BSgenome} package. If not already installed, \QuasR{} will download and install the package. The aligner index will also be generated and stored as an \R{} package, avoiding multiple indices being generated for the same genome. This is the preferred way of selecting the reference genome:
<<selectGenomeBSgenome, eval=TRUE>>=
available.genomes()
gnm <- "BSgenome.Dmelanogaster.UCSC.dm3"
@
\item{\textbf a directory name}, referring to a directory containing one or several sequence files in \fasta{} format, identified by their file extension (one of '.fa', '.fna' or '.fasta':
<<selectGenomeDirectory, eval=FALSE>>=
gnm <- system.file(package="QuasR", "extdata", "phage_genomes")
@
\item{\textbf a file name}, referring to a sequence file containing one or several reference sequences (e.g. chromosomes) in \fasta{} format:
<<selectGenomeFile, eval=FALSE>>=
gnm <- system.file(package="QuasR", "extdata", "phage_genomes", "NC_001422.1.fa")
@
\end{itemize}

In most cases, specifying the reference genome as a \Rpackage{BSgenome} package should be the easiest and safest option. Genomes in \fasta{} format are supported for cases where a \Rpackage{BSgenome} package is not available or complicated to generate.


\subsection{Sequence data pre-processing}
\label{sec:workflowPreprocess}
The \Rfunction{preprocessReads} function can be used to prepare the input sequence files prior to the main analysis. The function takes one or several sequence files (or pairs of files for a paired-end experiment) in \fasta{} or \fastq{} format as input and produces the same number of output files with the processed reads.

In the following example, we truncate the reads by removing three bases from the 3'-end (the right side), remove the adapter sequence \texttt{AAAAAAAAAA} from the 5'-end (the left side) and filter out reads that are shorter than 14 bases (after truncation and adapter removal) or contain more than 2 \texttt{N} bases:
<<preprocessReadsSingle,eval=TRUE>>=
td <- tempdir()
infiles <- system.file(package="QuasR", "extdata",
                       c("sr_phiX174_1_1.fastq","sr_phiX174_2_1.fastq"))
outfiles <- file.path(td, basename(infiles))
res <- preprocessReads(filename = infiles,
                       outputFilename = outfiles,
                       truncateEndBases = 3,
                       Lpattern = "AAAAAAAAAA",
                       minLength = 14, 
                       nBases = 2)
res
@ 

In the example below we process paired-end reads, removing all pairs with more \texttt{N} bases. Even if only one sequence in a pair fulfills the filtering criteria, both reads in the pair are removed, thereby preserving the matching order of the sequences in the two files:
<<preprocessReadsPaired,eval=TRUE>>=
td <- tempdir()
infiles1 <- system.file(package="QuasR", "extdata", "sr_dm_1_1.fastq")
infiles2 <- system.file(package="QuasR", "extdata", "sr_dm_1_2.fastq")
outfiles1 <- file.path(td, basename(infiles1))
outfiles2 <- file.path(td, basename(infiles2))
res <- preprocessReads(filename=infiles1,
                       filenameMate=infiles2,
                       outputFilename=outfiles1,
                       outputFilenameMate=outfiles2,
                       nBases=0)
res
fastq.geometry(outfiles1)[1]
fastq.geometry(outfiles2)[1]
@ 

More details on the \Rfunction{preprocessReads} function can be found in the function documentation (see \Rcode{?preprocessReads}) and in the section \ref{sec:preprocessReads} on page \pageref{sec:preprocessReads}.


\newpage
\section{Example workflows}
\subsection{ChIP-seq}
\label{sec:ChIP}
Here we show an exemplary single-end ChIP-seq workflow using sequence data that was obtained from a control experiment with genomic DNA from bacteriophage $\Phi$X174. All necessary files are included in the \QuasR{} package.

\subsubsection{Create a \qProject{} object}
We assume that the sequence reads have already been pre-processed as described in section \ref{sec:workflowPreprocess} on page \pageref{sec:workflowPreprocess}. Also, a sample file (section \ref{sec:SampleFile} on \pageref{sec:SampleFile}) that lists all sequence files to be analyzed has been prepared. \fasta{} files with $\Phi$X174 and $\Lambda$ bacteriophage genomes (reference and auxiliary) have been downloaded (sections \ref{sec:refGenome} on page \pageref{sec:refGenome}) and the auxiliary genome is listed in an auxiliary file (section \ref{sec:AuxFile} on page \pageref{sec:AuxFile}). Finally, we provide a directory (here the temporary directory of the current \R{} session as returned by \Rfunction{tempdir}) for storing newly generated \bam{} files using the \Rfunarg{bamfileDir} argument. Everything is ready to start the analysis and create a \qProject{} object:

<<qProject, eval=TRUE>>=
sampleFile <- system.file(package="QuasR", "extdata",
                          "samples_phiX_single.txt")
gnm <- system.file(package="QuasR", "extdata",
                   "phage_genomes", "NC_001422.1.fa")
aux <- system.file(package="QuasR", "extdata",
                   "auxiliaries.txt")
td <- tempdir()
project <- qProject(sampleFile, genome=gnm, auxiliaryFile=aux, bamfileDir=td)
project
@

The \qProject{} object was assigned to the variable \Robject{project}, and typing its name will show its content: the (optional) project name, the project parameters, aligner package, reference genome and auxiliaries, and at the bottom the sequence and alignment files. At this point, alignments have not yet been generated and are shown as missing values (\Rcode{NA}). If \bam{} alignments have been provided as input in the samples file, or if compatible alignment files were found on the disk, their path and filenames would be contained in \Robject{project}. In this example however, the alignments do not exist yet and will have to be generated by \Rfunction{qAlign}:

<<tempdir1, eval=TRUE>>=
list.files(td, pattern=".bam$")
@

\subsubsection{Align reads using the \Rfunction{qAlign} function}
\Rfunction{qAlign} will start by searching the alignment index of the selected reference genome, and create it if none is found. Then individual sequence files will be aligned to the genome, converted to \bam{} format, sorted and indexed for fast access. The number of hits per read will be counted and added to the \bam{} file as well, so it can be used later in the quality control report and for alignment weighting. 
<<qAlign, eval=TRUE>>=
qAlign(project)
project
@
The \Rcode{Alignments} section now lists \bam{} files for reference genome and all auxiliary sequences, one for each input sequence file.

A look at the \bam{} file directory shows all alignment files that have been generated so far:
<<tempdir2, eval=TRUE>>=
list.files(td, pattern=".bam$")
@

The file names of reference genome \bam{} files are a combination of the input sequence file name, the reference genome name, and a randomly generated string that prevents alignments to be overwritten that happen to have identical sequence file and genome names. When searching for pre-existing \bam{} files, \QuasR{} verifies additional information (e.g. alignment parameters) contained in the headers of candidate \bam{} files to decide if alignments can be reused or new alignments have to be generated.

The file names of auxiliary reference \bam{} files are a combination of the corresponding reference genome \bam{} file name, the suffix of \texttt{\_unmapped}, the name of the auxiliary and another random string. The \texttt{\_unmapped} suffix illustrates that only sequence reads without hits to the reference genome will be further aligned to the auxiliaries.

The temporary directory of the \R{} session and all contained files will be deleted when the session ends, which is fine in the case of our example. If the \bam{} files are supposed to survive the current \R{} session for later reuse, a more permanent directory should be used as \Rfunarg{bamfileDir}, or else the default value of \Rcode{bamfileDir=NULL} can be used when creating the \qProject{} object. The latter will cause \QuasR{} to store the \bam{} files at their default location, in the directory containing the input sequence files, where they can be found again.

\subsubsection{Create a quality control report}
\QuasR{} can produce a quality control plot in the form of a series of diagnostic plots with details on sequences and alignments (quality control 1 and 2 in Figure \ref{fig:QuasR-scheme} on page \pageref{fig:QuasR-scheme}). The plots are generated using the \Rfunction{qQCReport} function on the \Robject{pProject} object. \Rfunction{qQCReport} uses \Rpackage{ShortRead} \cite{ShortRead} internally to obtain some of the quality metrics, and some of the additional plots are inspired by the FastQC quality control tool by Simon Andrews (\url{http://www.bioinformatics.bbsrc.ac.uk/projects/fastqc/}). The plots will be stored into a multipage PDF document defined by the \Rfunarg{pdfFilename} argument, or else shown as individual plot windows on the current graphics device. In order to keep the running time reasonably short, some quality metrics are obtained from a random subsample of the sequences or alignments. Currently available plots are described in section \ref{sec:qQCReport} on page \pageref{sec:qQCReport}.

<<qcplots1, eval=FALSE>>=
qQCReport(project, pdfFilename="qc_report.pdf")
@
<<qcplots2, eval=TRUE, echo=FALSE>>=
qQCReport(project, pdfFilename=file.path(td,"qc_report.pdf"))
@


\subsubsection{Count alignments using the \Rfunction{qCount} function}
TODO
%<<qCount, eval=FALSE>>=
%library(TxDb.Dmelanogaster.UCSC.dm3.ensGene)
%txdb <- TxDb.Dmelanogaster.UCSC.dm3.ensGene
%isActiveSeq(txdb)[seqlevels(txdb)] <- FALSE
%isActiveSeq(txdb)["chr2L"] <- TRUE
%gr <- transcripts(txdb)
%cnt <- qCount(project, gr, collapseSamples=T, overlap="within")
%@

\subsubsection{Saving and restoring \qProject{} objects}
As mentioned the \qProject{} object keeps track of the current analysis. In this object, functions such as \Rfunction{qAlign} or \Rfunction{qExportWig} find all necessary information to perform their tasks. In addition, these functions can add further information to the \qProject{} object, for example the path to \bam{} files added by \Rfunction{qAlign}, or quality metrics added by \Rfunction{qQCReport}.

At the end of an \R{} session it is therefore recommended to save the \qProject{} object into a file, from which it can later be restored. This can be done using the \Rfunction{qSaveProject} and \Rfunction{qReadProject} functions, which internally use \R{}'s \Rfunction{saveRDS} and \Rfunction{readRDS} functions, but perform some additional checks, e.g. if the files referenced in the \qProject{} object still exist.
<<saveRestore, eval=FALSE>>=
projectFilename <- qSaveProject(project)
project <- qReadProject(projectFilename)
@

Even if the \qProject{} object is not saved at the end of an \R{} session, none of the contained information is completely lost. As illustrated in figure \ref{fig:QuasR-scheme}, all input and primary output data is stored as files on the storage system. Using the same inputs, a \qProject{} object can be recreated easily by re-running the original analysis script, and no new alignments will be generated if the \bam{} files still exist on the storage. Only some derived data will have to be re-calculated, such as alignment statistics and quality metrics, because these are only contained in the \qProject{} object and not stored as individual files. Re-calculating this kind of data will in most cases take little time compared to the time needed to generate the alignments, but the \Rfunction{qSaveProject} and \Rfunction{qReadProject} functions can be used to avoid the need for recalculation altogether.

%\newpage
%\section{Example workflow with a \Rpackage{BSgenome} as genome}
%<<BSgenomeProject, eval=FALSE>>=
%td <- tempdir()
%sampleFile <- system.file(package="QuasR", "extdata", "samples.txt")
%annotationFile <- system.file(package="QuasR", "extdata", "annotations.txt")
%available.genomes()
%gnm <- "BSgenome.Dmelanogaster.UCSC.dm3"
%project <- qProject(sampleFile, genome=gnm, annotationFile=annotationFile, path=td, aligner="Rbowtie")
%project <- qAlign(project)
%projectFilename <- qSaveProject(project)
%project <- qReadProject(projectFilename)
%@
%
%\section{Example workflow with fasta files as genome}
%<<fastaProject, eval=FALSE>>=
%td <- tempdir()
%sampleFile <- system.file(package="QuasR", "extdata", "samples.txt")
%annotationFile <- system.file(package="QuasR", "extdata", "annotations.txt")
%#gnm <- file.path(td, "sacCer2")
%#url <- "ftp://hgdownload.cse.ucsc.edu/goldenPath/sacCer2/bigZips/chromFa.tar.gz"
%#destFile <- file.path(td, basename(url))
%#download.file(url, destFile, "curl")
%#untar(destFile, exdir=gnm, verbose=T)
%gnm <- "data/sacCer2"
%project <- qProject(sampleFile, genome=gnm, annotationFile=annotationFile, path=td)
%project <- qAlign(project)
%@

\newpage
\section{Description of Individual \QuasR{} Functions}
Please refer to the \QuasR{} reference manual or the function documentation (e.g. using \Rcode{?qAlign}) for a complete description of all details on \QuasR{} functions. The descriptions provided below are meant to give and overview over all functions and summarize the purpose of each one.

\subsection{\Rfunction{preprocessReads}}
\label{sec:preprocessReads}
The \Rfunction{preprocessReads} can be used to prepare the input sequences before aligning the to the reference genome, for example filtering out low quality reads that are unlikely to produce meaningful alignments. When working with data paired-end experiments, the paired reads are expected to be contained in two separate files in identical order. In that case, both reads of a pair are filtered out if any of the two reads fulfills the filtering criteria. The following types of filtering tasks can be performed (in the order as listed):
\begin{quote}
\begin{enumerate}
\item \textbf{Truncate reads}: remove nucleotides from the start and/or end of each read.
\item \textbf{Trim adapters}: remove nucleotides at the beginning and/or end of each read that match to a defined (adapter) sequence. The adapter trimming is done by calling \Rfunction{trimLRPatterns} from the \Rpackage{Biostrings} package \cite{Biostrings}.
\item \textbf{Filter out low quality reads}: Filter out reads that fulfill any of the filtering criteria (contain more than \Rfunarg{nBases} \texttt{N} bases, are shorter than \Rfunarg{minLength} or have a dinucleotide complexity of less than \Rfunarg{complexity}-times the average complexity of the human genome sequence).
\end{enumerate}
\end{quote}

\subsection{\Rfunction{qProject}}
\label{sec:qProject}
TODO

\subsection{\Rfunction{qAlign}}
\label{sec:qAlign}
TODO\cite{SpliceMap}

\subsection{\Rfunction{qCount}}
\label{sec:qCount}
TODO

\subsection{\Rfunction{qQCReport}}
\label{sec:qQCReport}
The \Rfunction{qQCReport} function samples a random subset of sequences and alignments from each sample and generates a series of diagnostic plots for estimating data quality. The plots below show the currenly available plots as produced by the ChIP-seq example in section \ref{sec:ChIP}:
\setkeys{Gin}{width=0.7\textwidth}
\begin{itemize}
\item \textbf{Quality score boxplot} shows the distribution of base quality values as a box plot for each position in the input sequence. The background color (green, orange or red) indicates ranges of high, intermediate and low qualtities. The plot is available for \fastq{} and external \bam{} files.
\begin{center}
<<qcplotsFig1, eval=TRUE, echo=FALSE, fig=TRUE, height=6, width=8>>=
QuasR:::.plotQualByCycle(project@env$qc$qa, lmat=rbind(1:2,3:4))
@
\end{center}

\item \textbf{Nucleotide frequency} plot shows the frequency of A, C, G, T and N bases by position in the input sequence.
\begin{center}
<<qcplotsFig2, eval=TRUE, echo=FALSE, fig=TRUE, height=6, width=8>>=
QuasR:::.plotNuclByCycle(project@env$qc$qa, lmat=rbind(1:2,3:4))
@
\end{center}

\item \textbf{Duplication level} plot shows for each sample the fraction of reads observed at different duplication levels (e.g. once, two-times, three-times, etc.). In addition, the most frequent sequences are listed.
\begin{center}
<<qcplotsFig3, eval=TRUE, echo=FALSE, fig=TRUE, height=6, width=8>>=
QuasR:::.plotDuplicated(project@env$qc$qa, lmat=rbind(1:2,3:4))
@
\end{center}

\item \textbf{Mapping statistics} shows the number and fraction of reads that were unmappable, or that were mapped with different numbers of hits to the reference genome are shown. This plot is available for projects with alignments created by the \Rfunction{qAlign} function.
\begin{center}
<<qcplotsFig4, eval=TRUE, echo=FALSE, fig=TRUE, height=6, width=8>>=
QuasR:::.plotMappings(project@env$qc$mappingStats$genome)
@
\end{center}

\item \textbf{Mismatch frequency} shows the frequency and position (relative to the short read) of mismatches in the alignments against the reference genome. This plot is available for projects with alignments created by the \Rfunction{qAlign} function.
\begin{center}
<<qcplotsFig5, eval=TRUE, echo=FALSE, fig=TRUE, height=6, width=8>>=
label <- as.character(project@env$samples$name)
for(x in as.character(unique(label))){
    idx <- label == x
    if(sum(idx) > 1)
        label[idx] <- paste(label[idx], ".", 1:sum(idx), sep="")
}
bamfilename <- project@env$alignments$genome
names(bamfilename) <- label
QuasR:::.plotErrorsByCycle(bamfilename, N=1e6, lmat=rbind(1:2, 3:4))
@
\end{center}

\end{itemize}
\setkeys{Gin}{width=0.8\textwidth}

% from: http://r.789695.n4.nabble.com/How-to-include-the-documentation-of-a-function-in-a-Sweave-document-td849350.html
% may need header:
%\usepackage[times,hyper]{Rd}
%\usepackage[latin1]{inputenc}
%\usepackage{makeidx}
% when building the binary package, use --latex to include latex function documentations:
%R CMD INSTALL --latex --build QuasR

%<<echo=FALSE,print=FALSE,results=tex>>=
%path <- sub("help","latex",as.character(?qQCReport))
%path <- paste(path,'tex',sep=".")
%cat(readLines(path),sep="\n")
%@

\subsection{\Rfunction{qExportWig}}
\label{qExportWig}
TODO

\subsection{\Rfunction{qSaveProject} and \Rfunction{qReadProject}}
TODO

\section{Session information}
The output in this vignette was produced under the following conditions:
<<sessionInfo>>=
sessionInfo()
@

\bibliography{QuasR-refs}

\end{document}


% LocalWords:  nnotate hort antify Rintro SampleFile qProject qAlign qCount pre
% LocalWords:  qQCReport qExportWig qSaveProject qReadProject TODO BSgenome fq
% LocalWords:  SampleName FileName fasta fastq fna txt auxiliaryFile AuxName Qu
% LocalWords:  edgeR DESeq Rbowtie Html limma https postingGuide html ethz www
% LocalWords:  listinfo Lerch Dalgaard metadata projectFilename SpliceMap dm
% LocalWords:  filename infiles AAAAAAAAAA truncateEndBases trimLRPatterns
% LocalWords:  Biostrings nBases minLength outfiles saveRDS readRDS
